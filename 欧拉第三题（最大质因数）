#include<stdio.h>
#include<inttypes.h>
#define Num 600851475143
int main()
{
    int64_t num = Num,n = 2,ans = 0;
    while(n * n <= num)
    {
        if(num%n == 0 ) ans = n;//由于每个数都能分解为多个非递减质数的乘积 且序列唯一。（质因数小于等于原数）
        while(num % n == 0)num /= n;//每一次当num%n==0时，num=num/n，n=n+1,使得在保证num的值在去除小的质因数后的值不被n整除，也就是假如num=n1*n2*......*nx,那么num/n=nk*.......*nx,由此可见，假如n=5时，那么代表的是num把前面他含有的质因数除完了，且每个由2,3,5三个数以任何方式组合而得的的乘积如2*2,2*3,2*2*2，3*3,2*2*3，......都不可能成为ans，由每个数都能分解为多个非递减质数可得合数肯定能分解为比他小的素数之积而比他小的质数已经在前面被除了，所以ans只能为质数。
        n += 1;
    }
    if(num!=1)ans=num;//当num==1时，说明num曾等于(n-1)*(n-1),所以ans=n，当num!=1时，由每个数都能分解为多个非递减质因数序列的乘积可得，num>n-1,且num为质数。
    printf("%"PRId64"\n",ans);
    return 0;
}
/*反证法：
 * （1）
 * 由题可知循环从n=2开始；
 * 假如n为合数，那么设n=x×y，（x>0,y>0,x,y为正整数），则有Num%x==0,Num%y==0，且x，y若为合数那么num曾吧x，y的唯一质数序列除尽了，所以num%n>0
 * 与原条件矛盾。所以n为质数。
 * （2）假如num为合数，那么说明num中还有比num^1/2大的因子，即大于等于n+1的因子，假设（n+1）×k=num,则必有k>=n,即num>=n*n+n与n×n>num矛盾，所以假设不成立，num为质数。
 */
